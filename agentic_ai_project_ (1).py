# -*- coding: utf-8 -*-
"""Agentic AI Project .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I0PLyDLR6kUvsexU1WztY_ipJeiD29FZ

User (chat)
   ↓
Planning Agent (LLM)
   ↓
Reasoning (Thought)
   ↓
Tool choice (SQL / RAG / Optimizer / MCP)
   ↓
Observation
   ↓
Final answer + explanation
"""

!pip install pandas numpy -q

import sqlite3
import json
import pandas as pd
from dataclasses import dataclass, field
from datetime import datetime

DB_PATH = "city_planning.db"

CITY_PROFILE = {
    "city_name": "Metroville",
    "population": 2_500_000,
    "quarterly_budget": 75_000_000
}


RISK_THRESHOLDS = {
    "high_population": 100_000,
    "high_complaints": 75,
    "high_risk_score": 3
}


RISK_WEIGHTS = {
    "safety_risk": 3,
    "legal_mandate": 3,
    "population_impact": 1,
    "complaint_volume": 1
}

# ---- Crew mapping ----
CREW_MAPPING = {
    "Water": "water_crew",
    "Health": "electrical_crew",
    "Disaster Management": "construction_crew",
    "Infrastructure": "construction_crew",
    "Recreation": "general_crew",
    "Education": "general_crew"
}

def init_database():
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()

    cur.executescript("""
    CREATE TABLE IF NOT EXISTS issues (
        issue_id INTEGER PRIMARY KEY,
        title TEXT,
        category TEXT,
        description TEXT,
        source TEXT,
        status TEXT
    );

    CREATE TABLE IF NOT EXISTS issue_signals (
        issue_id INTEGER,
        population_affected INTEGER,
        complaint_count INTEGER,
        safety_risk INTEGER,
        legal_mandate INTEGER,
        estimated_cost REAL,
        urgency_days INTEGER
    );
    """)

    conn.commit()
    conn.close()

init_database()

def seed_data():
    """Seed data matching the original codebase for consistent outputs."""
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()

    # Clear existing data first (safe for reruns)
    cur.execute("DELETE FROM issues")
    cur.execute("DELETE FROM issue_signals")

    issues_data = [
        (1, "Major Water Pipeline Rupture", "Water",
         "Critical water main break affecting downtown area", "emergency_report", "OPEN"),
        (2, "Hospital Power Backup Failure", "Health",
         "Primary backup generator at City Hospital non-functional", "facility_inspection", "OPEN"),
        (3, "Urban Flooding in Low-Lying Areas", "Disaster Management",
         "Recurring flooding in Districts 4 and 7 during monsoon", "citizen_complaint", "OPEN"),
        (4, "Pothole Complaints in Residential Zones", "Infrastructure",
         "Multiple potholes reported on Main St and Oak Ave", "citizen_complaint", "OPEN"),
        (5, "Public Park Renovation Delay", "Recreation",
         "Central Park playground equipment outdated", "council_request", "OPEN"),
        (6, "Street Light Outages", "Infrastructure",
         "Multiple street lights non-functional in Sector 12", "citizen_complaint", "OPEN"),
        (7, "School Zone Safety Improvements", "Education",
         "Need for crosswalks and speed bumps near Lincoln Elementary", "citizen_complaint", "OPEN"),


        (8, "Traffic Signal Failures at Major Intersections", "Transportation",
         "Traffic lights malfunctioning at 5 high-traffic junctions", "traffic_department", "OPEN"),
        (9, "Sewer Line Overflow in Downtown", "Sanitation",
         "Sewer overflow causing road closures and health concerns", "emergency_report", "OPEN"),
        (10, "Fire Hydrant Pressure Issues", "Public Safety",
         "Low water pressure detected in fire hydrants", "fire_department", "OPEN"),


        (11, "Public Bus Route Delays", "Transportation",
         "Frequent delays reported on Routes 12 and 19", "citizen_complaint", "OPEN"),
        (12, "Waste Collection Backlog", "Sanitation",
         "Missed garbage pickups in multiple residential areas", "citizen_complaint", "OPEN"),
        (13, "Air Quality Sensor Network Failure", "Environment",
         "Several air quality monitoring sensors offline", "environmental_monitor", "OPEN"),
        (14, "City IT System Cybersecurity Incident", "IT",
         "Suspicious login attempts detected on municipal servers", "security_audit", "OPEN"),
    ]

    signals_data = [
        (1, 450000, 1200, 1, 1, 45000000, 7),
        (2, 180000, 300, 1, 1, 12000000, 14),
        (3, 600000, 900, 1, 0, 60000000, 30),
        (4, 80000, 40, 0, 0, 4000000, 60),
        (5, 15000, 12, 0, 0, 2500000, 180),
        (6, 25000, 85, 1, 0, 800000, 45),
        (7, 5000, 150, 1, 0, 500000, 30),
        (8, 220000, 500, 1, 0, 3500000, 10),   # Traffic signal failures
        (9, 160000, 260, 1, 1, 9000000, 14),   # Sewer overflow
        (10, 300000, 90, 1, 0, 1500000, 21),   # Fire hydrant safety
        (11, 120000, 400, 0, 0, 2200000, 45),  # Public transport delays
        (12, 90000, 600, 0, 0, 1800000, 20),   # Waste collection backlog
        (13, 500000, 30, 1, 1, 7000000, 60),   # Environmental monitoring
        (14, 650000, 5, 1, 1, 5000000, 5),     # Cybersecurity incident
    ]

    cur.executemany(
        "INSERT INTO issues (issue_id, title, category, description, source, status) VALUES (?, ?, ?, ?, ?, ?)",
        issues_data
    )

    cur.executemany(
        "INSERT INTO issue_signals (issue_id, population_affected, complaint_count, safety_risk, legal_mandate, estimated_cost, urgency_days) VALUES (?, ?, ?, ?, ?, ?, ?)",
        signals_data
    )

    conn.commit()
    conn.close()
    print("✓ Sample data seeded with extended scenarios")

seed_data()
print("Database re-seeded.")

import sqlite3
import pandas as pd

conn = sqlite3.connect(DB_PATH)

issues_df = pd.read_sql_query("SELECT * FROM issues", conn)
print("Issues Table after re-seeding:")
display(issues_df)

issue_signals_df = pd.read_sql_query("SELECT * FROM issue_signals", conn)
print("Issue Signals Table after re-seeding:")
display(issue_signals_df)

conn.close()

!pip install -q openai langchain

import sqlite3
import os
from typing import Dict

# Corrected import for ChatOpenAI
# from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, HumanMessage

!pip install -q openai-agents

!pip install -q langchain-openai

import os
os.environ["OPENAI_API_KEY"] = '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'  # <-- put your key here

"""Agent 1"""

pip install openai-agents

from agents import function_tool
from agents import Agent, Runner, function_tool, trace, custom_span, RunConfig

DB_PATH = "city_planning.db"

conn = sqlite3.connect(DB_PATH)
cursor = conn.cursor()

import json
from agents import function_tool
import sqlite3

@function_tool
def fetch_issues() -> str:
    """
    Fetch all current city issues and return a human-readable string summary.
    The summary includes 'issue_id', 'title', and 'category' for each issue.
    """
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()

    cur.execute("""
        SELECT issue_id, title, category
        FROM issues
    """)
    rows = cur.fetchall()

    conn.close()

    if not rows:
        return "No issues found."

    summary_lines = []
    for r in rows:
        summary_lines.append(f"ID: {r[0]}, Title: {r[1]}, Category: {r[2]}")

    return "\n".join(summary_lines)

from agents import function_tool
import sqlite3

@function_tool
def fetch_issue_signals(issue_id: int) -> dict:
    """
    Fetch specific signal values for a given issue_id.
    Returns a dictionary with keys: population_affected, complaint_count, safety_risk, legal_mandate.
    """
    conn = sqlite3.connect(DB_PATH)
    cur = conn.cursor()

    cur.execute("""
        SELECT
            population_affected,
            complaint_count,
            safety_risk,
            legal_mandate
        FROM issue_signals
        WHERE issue_id = ?
    """, (issue_id,))
    row = cur.fetchone()

    conn.close()

    if row:
        return {
            "population_affected": row[0],
            "complaint_count": row[1],
            "safety_risk": row[2],
            "legal_mandate": row[3]
        }
    return {}

@function_tool
def compute_risk_score(
    safety_risk: int,
    legal_mandate: int,
    population_impact: int,
    complaint_volume: int
) -> int:
    """
    Compute a weighted risk score using predefined risk weights.

    Use this after extracting individual signal values.
    """
    score = (
        safety_risk * RISK_WEIGHTS["safety_risk"] +
        legal_mandate * RISK_WEIGHTS["legal_mandate"] +
        population_impact * RISK_WEIGHTS["population_impact"] +
        complaint_volume * RISK_WEIGHTS["complaint_volume"]
    )
    return score

@function_tool
def rank_risks(
    issue_ids: list[int],
    risk_scores: list[int]
) -> list[str]:
    """
    Rank issues by relative risk.

    Returns a list of risk tiers aligned with issue_ids.
    """
    paired = list(zip(issue_ids, risk_scores))
    paired.sort(key=lambda x: x[1], reverse=True)

    n = len(paired)
    tiers_by_id = {}

    for i, (issue_id, score) in enumerate(paired):
        percentile = i / n
        if percentile < 0.2:
            tier = "Critical"
        elif percentile < 0.5:
            tier = "High"
        else:
            tier = "Moderate"
        tiers_by_id[issue_id] = tier


    return [tiers_by_id[i] for i in issue_ids]

@function_tool
def explain_risk(issue_type: str, tier: str, score: int) -> str:
    """
    Explain why an issue falls into a given risk tier.
    """
    return (
        f"The issue '{issue_type}' is classified as {tier} risk "
        f"legal obligations, affected population, and complaint volume."
    )

risk_agent = Agent(
    name="Municipal Risk Assessment Agent",
    instructions="""
You are a municipal risk assessment agent.

Your responsibilities:
- Identify current city issues
- Analyze quantitative signals
- Compute transparent risk scores
- Rank issues by relative urgency
- Explain why some issues are more critical than others

TOOL RULES:
- Use fetch_issues to get the list of problems.
- Use fetch_issue_signals to gather evidence.
- Use compute_risk_score to quantify risk.
- Use rank_risks to prioritize issues.
- Use explain_risk to communicate findings.

IMPORTANT:
- Do NOT propose solutions.
- Do NOT allocate budgets.
- Do NOT schedule work.
""",
    tools=[
        fetch_issues,
        fetch_issue_signals,
        compute_risk_score,
        rank_risks,
        explain_risk
    ]
)

result = await Runner.run(
    risk_agent,
    "Assess the current city issues and explain which ones are most urgent."
)

print(result.final_output)

"""Agent 2"""

from agents import function_tool, RunContextWrapper
from typing import List, Dict


@function_tool
def get_enriched_project_candidates(
    ctx: RunContextWrapper["MunicipalContext"]
) -> List[Dict]:
    """
    Fetch project candidates and enrich them with legal mandate information.
    """
    candidates = ctx.context.get_project_candidates()

    enriched = []
    for c in candidates:
        issue = ctx.context.get_issue_by_id(c["issue_id"])
        enriched.append({
            **c,
            "legal_mandate": issue.get("legal_mandate", 0) if issue else 0
        })

    return enriched

from typing import TypedDict, Optional


class ProjectCandidate(TypedDict):
    project_id: int
    issue_id: int
    risk_score: float
    estimated_cost: float
    legal_mandate: int

class ApprovedProject(ProjectCandidate):
    priority_rank: int
    rationale: str

class RejectedProject(ProjectCandidate):
    rationale: str

from typing import List


@function_tool
def approve_legal_mandates(
    projects: List[ProjectCandidate],
    starting_budget: float
) -> dict:
    """
    Approve all legal-mandate projects first, sorted by risk score.
    """
    approved: List[ApprovedProject] = []
    remaining_budget = starting_budget
    priority_rank = 1

    mandates = [p for p in projects if p["legal_mandate"]]

    for p in sorted(mandates, key=lambda x: x["risk_score"], reverse=True):
        if p["estimated_cost"] <= remaining_budget:
            approved.append({
                **p,
                "priority_rank": priority_rank,
                "rationale": f"Legal mandate requirement (risk_score={p['risk_score']})"
            })
            remaining_budget -= p["estimated_cost"]
            priority_rank += 1

    return {
        "approved": approved,
        "remaining_budget": remaining_budget,
        "next_priority_rank": priority_rank
    }

@function_tool
def approve_by_value_density(
    projects: List[ProjectCandidate],
    starting_budget: float,
    starting_priority_rank: int
) -> dict:
    approved: List[ApprovedProject] = []
    rejected: List[RejectedProject] = []
    remaining_budget = starting_budget
    priority_rank = starting_priority_rank

    for p in projects:
        p["value_density"] = p["risk_score"] / (p["estimated_cost"] / 1_000_000)

    projects.sort(key=lambda x: x["value_density"], reverse=True)

    for p in projects:
        if p["estimated_cost"] <= remaining_budget:
            approved.append({
                **p,
                "priority_rank": priority_rank,
                "rationale": (
                    f"High value density "
                    f"(risk_score={p['risk_score']}, cost=${p['estimated_cost']:,.0f})"
                )
            })
            remaining_budget -= p["estimated_cost"]
            priority_rank += 1
        else:
            rejected.append({
                **p,
                "rationale": (
                    f"Budget exhausted. Remaining=${remaining_budget:,.0f}, "
                    f"Required=${p['estimated_cost']:,.0f}"
                )
            })

    return {
        "approved": approved,
        "rejected": rejected,
        "remaining_budget": remaining_budget
    }

class ApprovedProject(ProjectCandidate):
    priority_rank: int
    rationale: str


class RejectedProject(ProjectCandidate):
    rationale: str

from typing import List
from agents import function_tool, RunContextWrapper


@function_tool
def persist_governance_decisions(
    ctx: RunContextWrapper["MunicipalContext"],
    approved: List[ApprovedProject],
    rejected: List[RejectedProject],
    remaining_budget: float
) -> dict:
    """
    Persist governance approval/rejection decisions and write audit logs.
    """

    for p in approved:
        ctx.context.insert_portfolio_decision(
            project_id=p["project_id"],
            decision="APPROVED",
            allocated_budget=p["estimated_cost"],
            priority_rank=p["priority_rank"],
            rationale=p["rationale"]
        )

    for p in rejected:
        ctx.context.insert_portfolio_decision(
            project_id=p["project_id"],
            decision="REJECTED",
            allocated_budget=0,
            priority_rank=0,
            rationale=p["rationale"]
        )

    ctx.context.log_audit(
        event_type="PORTFOLIO_DECISION",
        agent_name="governance_agent",
        payload={
            "approved_count": len(approved),
            "rejected_count": len(rejected),
            "remaining_budget": remaining_budget
        }
    )


    return {
        "approved_count": len(approved),
        "rejected_count": len(rejected),
        "remaining_budget": remaining_budget
    }

from agents import Agent

governance_agent = Agent(
    name="Governance Approval Agent",
    instructions="""
You are a governance and budget allocation agent for a city.

Your responsibilities:
- Review project candidates created by the Risk Assessment Agent
- Approve all legal-mandate projects first
- Allocate remaining budget using greedy value-density optimization
- Persist approval and rejection decisions
- Maintain full audit logs

Rules:
- Do NOT create new projects
- Do NOT modify project estimates
- Do NOT schedule projects
- Budget discipline is mandatory
    """,
    tools=[
        get_enriched_project_candidates,
        approve_legal_mandates,
        approve_by_value_density,
        persist_governance_decisions
    ]
)

DB_PATH = "city_planning.db"

ctx = MunicipalContext(
    city_profile=CITY_PROFILE,
    risk_thresholds=RISK_THRESHOLDS,
    crew_mapping=CREW_MAPPING,
    db_path=DB_PATH
)


from agents import Runner

result = await Runner.run(
    governance_agent,
    "Approve projects within the quarterly budget.",
    context=ctx
)

print(result.final_output)

approved = ctx.get_approved_projects()
print("Approved projects count:", len(approved))
print(approved)

CITY_PROFILE = {
    "city_name": "Metroville",
    "population": 2_500_000,
    "quarterly_budget": 75_000_000
}

RISK_THRESHOLDS = {
    "high_population": 100_000,
    "high_complaints": 75,
    "high_risk_score": 3
}

CREW_MAPPING = {
    "Water": "water_crew",
    "Health": "electrical_crew",
    "Disaster Management": "construction_crew",
    "Infrastructure": "construction_crew",
    "Recreation": "maintenance_crew"
}

def get_approved_projects(self):
    """
    Fetch approved projects for scheduling, ordered by priority.
    """
    conn = sqlite3.connect(self.db_path)
    cursor = conn.cursor()

    cursor.execute("""
        SELECT
            project_id,
            allocated_budget,
            priority_rank
        FROM portfolio_decisions
        WHERE decision = 'APPROVED'
        ORDER BY priority_rank ASC
    """)

    rows = cursor.fetchall()
    conn.close()

    projects = []
    for row in rows:
        projects.append({
            "project_id": row[0],
            "allocated_budget": row[1],
            "priority_rank": row[2]
        })

    return projects

"""Agent 3

"""

from agents import function_tool, RunContextWrapper

@function_tool
def schedule_approved_projects(
    ctx: RunContextWrapper["MunicipalContext"]
) -> dict:
    """
    Schedule approved projects using priority order and crew availability.
    """
    projects = ctx.context.get_approved_projects()
    horizon = ctx.context.planning_horizon_weeks

    scheduled = []
    infeasible = []

    for p in sorted(projects, key=lambda x: x["priority_rank"]):
        if ctx.context.can_allocate_project(p, horizon):
            ctx.context.allocate_project(p)
            scheduled.append(p)
        else:
            infeasible.append(p)

    ctx.context.log_audit(
        event_type="SCHEDULING_COMPLETE",
        agent_name="scheduling_agent",
        payload={
            "scheduled": len(scheduled),
            "infeasible": len(infeasible)
        }
    )

    return {
        "scheduled_count": len(scheduled),
        "infeasible_count": len(infeasible)
    }

from agents import Agent

scheduling_agent = Agent(
    name="Scheduling Agent",
    instructions="""
You are a scheduling agent.

Rules:
- Use only approved projects
- Respect priority ranks
- Respect crew capacity and planning horizon
- Persist schedules and audit logs
- Do NOT modify budgets or approvals
    """,
    tools=[schedule_approved_projects]
)

from agents import Runner

async def run_full_pipeline(ctx):
    print("=== RUNNING RISK ASSESSMENT ===")
    await Runner.run(
        risk_agent,
        "Run risk assessment on current city issues.",
        context=ctx
    )

    print("=== RUNNING GOVERNANCE ===")
    await Runner.run(
        governance_agent,
        "Execute governance approval using system budget.",
        context=ctx
    )

    print("=== RUNNING SCHEDULING ===")
    result = await Runner.run(
        scheduling_agent,
        "Schedule all approved projects.",
        context=ctx
    )

    print("=== PIPELINE COMPLETE ===")
    return result.final_output

approved = ctx.get_approved_projects()
print("Approved projects count:", len(approved))
print(approved)

final_result = await run_full_pipeline(ctx)
print(final_result)

result = await Runner.run(
    scheduling_agent,
    "Schedule all approved projects.",
    context=ctx
)

print(result.final_output)







